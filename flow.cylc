#!jinja2

{# things written between hash and single braces is a Jinja comment. #}
{# Jinja code between single braces is run.                          #}
{# Jinja code with two braces is printed.                            #}

{# The site-specific file (stored in site/ subdir) is included at the end of this file.	              #}
{# (Probably, we should use similar mechanisms where sensible, e.g. for shared items among workflows) #}
{% set SITE = 'gfdl' %}
{# Calculate the number of history segments per a-slice #}
{% set HISTORY_SEGMENTS_PER_SLICE = (TIME_PER_A_SLICE | duration_as('s') / TIME_PER_HISTORY_SEGMENT | duration_as('s')) | int %}
{# Calculate the number of a-slices per b-slice (if desired) #}
{% set DO_SECONDARY_PP = False %}
{% if TIME_PER_B_SLICE is defined and TIME_PER_B_SLICE != TIME_PER_A_SLICE %}
    {% set A_SLICES_PER_B_SLICE = (TIME_PER_B_SLICE | duration_as('s') / TIME_PER_A_SLICE | duration_as('s')) | int %}
    {% set DO_SECONDARY_PP = True %}
{% endif %}

[meta]
    title = "Postprocessing Example 1"
    description = """
Postprocessing example that includes Bronx-like functionality,
"""
    URL = https://gitlab.gfdl.noaa.gov/fre2/workflows/postprocessing

[scheduler]
    {# Implicit tasks are tasks without explicit runtime definitions in [runtime], often typos. #}
    {# (For prototyping and graphing, change this to True.)                                     #}
    allow implicit tasks = False

    {# Configure the directories and files to be included in the remote file installation #}
    install = app/*, bin/*, etc/*, lib/*
    UTC mode = True

[task parameters]
{# The task parameters (except for component) depend on configuration in Rose apps,                            #}
{# so custom Jinja triggers are used to form the lists. Cylc and custom Jinja triggers have these rules:       #}
{# 1. Triggers live in Jinja2Filters/ and must be python						       #}
{# 2. The trigger filename must be <trigger-name>.py							       #}
{# 3. In the file, trigger must be defined as a function with the same name				       #}
{# 4. First argument is passed through as a pipe, and the rest are passed through in the trigger arguments.    #}
{# More info:												       #}
{# The python loaded within Cylc has access to some useful Cylc utilities (e.g. metomi.isodatetime.parsers).   #}
{# For development/testing, use "module load conda; conda activate cylc". Then the Cylc python will be loaded. #}
{% set REGRID  =  "regrid-xy" | form_task_parameters('temporal', PP_COMPONENTS) %}
{% set REGRID_STATIC  =  "regrid-xy" | form_task_parameters('static', PP_COMPONENTS) %}
{% set DO_REGRID = REGRID|length %}
{% if DO_REGRID %}
    regrid = {{ REGRID }}
    {% if DO_STATICS %}
    regrid_static = {{ REGRID_STATIC }}
    {% endif %}
{% endif %}

{% set NATIVE  =  "native" | form_task_parameters('temporal', PP_COMPONENTS) %}
{% set NATIVE_STATIC  =  "native" | form_task_parameters('static', PP_COMPONENTS) %}
{% set DO_NATIVE = NATIVE|length %}
{% if DO_NATIVE %}
    native = {{ NATIVE }}
    {% if DO_STATICS %}       
    native_static = {{ NATIVE_STATIC }}
    {% endif %}
{% endif %}

    {# Standard Jinja2 triggers are also available (e.g. "replace") #}
    component  =    {{ PP_COMPONENTS | replace(' ', ', ') }}

[scheduling]
    initial cycle point = {{ PP_START }}
    final cycle point = {{ PP_STOP }}
    {# Graph strings are organized by recurrence interval-- when to run the tasks.    #}
    {# Currently, we use 4 intervals: every history-file segment, once (for statics), #}
    {# every slice-a, and every slice-b.                                              #}
    [[graph]]
        #
        # Recurrence interval: every history-file segment
        #
        {{ TIME_PER_HISTORY_SEGMENT }} = """
{# Within a recurrence interval, task dependencies are specified with => (depends on), & (and), and | (or). #}
{# Tasks in a dependency can be single tasks, task families (by convention, in all caps),		    #}
{# or "ensembles" expanded by the parameters above.                                                         #}

{# All tasks in the STAGE-HISTORY family (staging history and staging history-refined) are started #}
{# once the pp-starter task succeeds.                                                              #}
pp-starter => STAGE-HISTORY

{# Jinja is useful to include or exclude parts of the configuration. In this case, the lines between              #}
{# if DO_REFINEDIAG and endif are used or not used, depending on the value of DO_REFINEDIAG (in rose-suite.conf). #}
{# All template variables in rose-suite.conf are available as Jinja variables.					  #}
{# If refineDiag generation is desired (DO_REFINEDIAG is True), then add these two task dependencies:		  #}
{# 1. All tasks in the REFINE-DIAG task family are started once the stage-history task succeeds.		  #}
{# 2. stage-history-refined task is started once all the refineDiag tasks succeed.                                #}
{% if DO_REFINEDIAG %}
stage-history => REFINE-DIAG
REFINE-DIAG:succeed-all => stage-history-refined
{% endif %}

{# If preAnalysis desired (vitals calculations is canonical case), start all PRE-ANALYSIS tasks when stage-history succeeds. #}
{% if DO_PREANALYSIS %}
stage-history => PRE-ANALYSIS
{% endif %}

{# If task families are on the left side of the => then a qualifier must be used (e.g. :succeed-all)                     #}
{# The angle brackets define the "ensemble" axis, the task paramaters defined above.					 #}
{# The next two lines set the major processing for the native and regrid (horizontal regridding) lists of history files. #}
{# Each history file to be regridded should be regridded once staging is done; then should be split and cataloged	 #}
{# (into a standard shards directory set by ISO8601 frequencies ).						 #}
{# Each history file needed for native grid processing is similar, except skipping the regridding.                       #}
{% if DO_REGRID %} 
STAGE-HISTORY:succeed-all => regrid-xy<regrid> => split-netcdf-regrid<regrid> => rename-split-to-pp-regrid<regrid>
{% endif %}

{% if DO_NATIVE %} 
STAGE-HISTORY:succeed-all =>                      split-netcdf-native<native> => rename-split-to-pp-native<native>
{% endif %}

{# If HISTORY_DIR_REFINED is set, then use the next 3 lines.                                                                #}
{# After all staging is done, then hard link the refined history files to the history file location (not a great solution). #}
{# Regridding and splitting native history files should not start until the history-refined output is available.            #}
{% if HISTORY_DIR_REFINED is defined %}
STAGE-HISTORY:succeed-all  => stage-history-refined-link
    {% if DO_REGRID %} 
stage-history-refined-link => regrid-xy<regrid>
    {% endif %}
    {% if DO_NATIVE %} 
stage-history-refined-link => split-netcdf-native<native>
    {% endif %}
{% endif %}

{# If work-dir cleaning is desired, then remove what should now be safe to remove.                                 #}
{# Once regridded history files are split, then the regridded history files can be removed.			   #}
{# Once the split (regridded and native) files are cataloged, then the (not-cataloged) split files can be removed. #}
{% if CLEAN_WORK %}
    {% if DO_REGRID %}
split-netcdf-regrid<regrid>       => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid> => clean-split-regrid-xy
    {% endif %}
    {% if DO_NATIVE %} 
rename-split-to-pp-native<native> => clean-split-native
    {% endif %}
{% endif %}
"""


        #
        # Recurrence interval R1: run only once. useful for statics.
        #
        R1 = """
{# The static processing is similar to the "every history segment" processing, except uses different history file lists. #}
pp-starter => STAGE-HISTORY
{% if DO_STATICS %}
    {% if DO_REGRID %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid_static> => split-netcdf-regrid<regrid_static> => rename-split-to-pp-regrid<regrid_static>
    {% endif %}
    {% if DO_NATIVE %} 
STAGE-HISTORY:succeed-all =>                             split-netcdf-native<native_static> => rename-split-to-pp-native<native_static>
    {% endif %}
{# After cataloging the regridded and native statics, remap them to pp components as desired #}
    {% if DO_NATIVE and DO_REGRID %} 
rename-split-to-pp-regrid<regrid_static> & rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
    {% elif DO_NATIVE %} 
rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
    {% elif DO_REGRID %} 
rename-split-to-pp-regrid<regrid_static> => remap-pp-components-static => combine-statics
    {% endif %}
{% endif %}

{# Similarly, if the history-refined is used, then don't process until the history-refined staging is done. #}
{% if HISTORY_DIR_REFINED is defined %}
STAGE-HISTORY:succeed-all => stage-history-refined-link
    {% if DO_STATICS %} 
        {% if DO_REGRID %} 
stage-history-refined-link => regrid-xy<regrid_static>
        {% endif %}
        {% if DO_NATIVE %} 
stage-history-refined-link => split-netcdf-native<native_static>
        {% endif %}
    {% endif %}
{% endif %}

{# If work-dir cleaning is set, then remove what should now be safe to remove. #}
{% if CLEAN_WORK and DO_STATICS %}
    {% if DO_REGRID %}
split-netcdf-regrid<regrid_static> => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid_static> => clean-split-regrid-xy
    {% endif %}
    {% if DO_NATIVE %} 
rename-split-to-pp-native<native_static> => clean-split-native
    {% endif %}
remap-pp-components-static => clean-shards-static
combine-statics => clean-pp-statics
{% endif %}
"""


        #
        # Recurrence interval: every SLICE-A
        #
        {# Run the tasks to process SLICE-A every SLICE-A, starting after TIME_PER_A_SLICE #}
        +{{ TIME_PER_A_SLICE | subtract_durations(TIME_PER_HISTORY_SEGMENT) }}/{{ TIME_PER_A_SLICE }} = """

{# Tasks can be split over multiple lines if the subsequent ones begin with =>, &, or |                   #}
{# The make-timeseries tasks for SLICE-A depend on all segment processing for the time period succeeding. #}
{# This Jinja for loop expands to do this.                                                                #}
{% if DO_REGRID %}
rename-split-to-pp-regrid<regrid>
    {% for SEGMENT in range(1, HISTORY_SEGMENTS_PER_SLICE) %}
& rename-split-to-pp-regrid<regrid>[{{ TIME_PER_HISTORY_SEGMENT | multiply_duration(-SEGMENT) }}]
    {% endfor %}
=> make-timeseries-regrid-{{ TIME_PER_A_SLICE }}<regrid>
{% endif %}

{% if DO_NATIVE %} 
rename-split-to-pp-native<native>
    {% for SEGMENT in range(1, HISTORY_SEGMENTS_PER_SLICE) %}
& rename-split-to-pp-native<native>[{{ TIME_PER_HISTORY_SEGMENT | multiply_duration(-SEGMENT) }}]
    {% endfor %}
=> make-timeseries-native-{{ TIME_PER_A_SLICE }}<native>
{% endif %}

{% if DO_REGRID %}
    {% set form_remap_dep_TIME_PER_A_SLICE_regrid  =  "regrid-xy" | form_remap_dep('temporal', TIME_PER_A_SLICE, PP_COMPONENTS) %}
    {{  form_remap_dep_TIME_PER_A_SLICE_regrid  }}
{% endif %}

{% if DO_NATIVE %}
    {% set form_remap_dep_TIME_PER_A_SLICE_native  =  "native" | form_remap_dep('temporal', TIME_PER_A_SLICE, PP_COMPONENTS) %}
    {{  form_remap_dep_TIME_PER_A_SLICE_native  }}
{% endif %}

{# If work-dir cleaning is desired, and (slice A is larger than the history segment, or, only one pp size is specified), remove (prerequisite) history shards. #}
{# If instead slice A is identical to the history segment, then do not remove the shards, as they haven't be saved (remapped) yet.                              #}
{% if CLEAN_WORK and TIME_PER_A_SLICE != TIME_PER_HISTORY_SEGMENT %}

    {% if DO_NATIVE and DO_REGRID %}
make-timeseries-regrid-{{ TIME_PER_A_SLICE }}<regrid> & make-timeseries-native-{{ TIME_PER_A_SLICE }}<native> & REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_HISTORY_SEGMENT }}
    {% elif DO_NATIVE %}
make-timeseries-native-{{ TIME_PER_A_SLICE }}<native> & REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_HISTORY_SEGMENT }}
    {% elif DO_REGRID %}
make-timeseries-regrid-{{ TIME_PER_A_SLICE }}<regrid> & REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_HISTORY_SEGMENT }}
    {% endif %}

{% endif %}

{# If MDTF is requested, then run it after all pp components have finished #}
{% if DO_MDTF %}
REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => mdtf
{% endif %}
"""


#
# Recurrence interval: every SLICE-B
#
{# If only one pp chunk is used, then skip the CHUNK-B processing. #}
{% if DO_SECONDARY_PP %}
        {# Run the tasks to process CHUNK-B every CHUNK-B, starting after CHUNK-B time #}
        +{{ TIME_PER_B_SLICE | subtract_durations(TIME_PER_HISTORY_SEGMENT) }}/{{ TIME_PER_B_SLICE }} = """

{# The make-timeseries tasks for SLICE-B depend on all CHUNK-A processing for the time period succeeding. #}
    {% if DO_REGRID %} 
make-timeseries-regrid-{{ TIME_PER_A_SLICE }}<regrid>
        {% for SLICE in range(1, A_SLICES_PER_B_SLICE) %}
& make-timeseries-regrid-{{ TIME_PER_A_SLICE }}<regrid>[{{ TIME_PER_A_SLICE | multiply_duration(-SLICE)}}]
        {% endfor %}
=> make-timeseries-regrid-{{ TIME_PER_B_SLICE }}<regrid>
    {% endif %}


    {% if DO_NATIVE %} 
make-timeseries-native-{{ TIME_PER_A_SLICE }}<native>
        {% for SLICE in range(1, A_SLICES_PER_B_SLICE) %}
& make-timeseries-native-{{ TIME_PER_A_SLICE }}<native>[{{ TIME_PER_A_SLICE | multiply_duration(-SLICE)}}]
        {% endfor %}
=> make-timeseries-native-{{ TIME_PER_B_SLICE }}<native>
    {% endif %}

{# Generate the per-component make-timeseries => remap-pp-component tasks using Jinja trigger form_remap_dep #}
{# Throw validation exception if TIME_PER_B_SLICE is not in rose-app.conf                                          #}
    {% if DO_REGRID %}
        {% set form_remap_dep_TIME_PER_B_SLICE_regrid  =  "regrid-xy" | form_remap_dep('temporal', TIME_PER_B_SLICE, PP_COMPONENTS) %}
        {{ form_remap_dep_TIME_PER_B_SLICE_regrid }}
    {% endif %}


    {% if DO_NATIVE %}
        {% set form_remap_dep_TIME_PER_B_SLICE_native  =  "native" | form_remap_dep('temporal', TIME_PER_B_SLICE, PP_COMPONENTS) %}
        {{ form_remap_dep_TIME_PER_B_SLICE_native }}
    {% endif %}

{# If work-dir cleaning is desired, remove CHUNK-A shards once CHUNK-B timeseries are created, #}
{# and remove CHUNK-B shards once the final products are saved.                                #}
    {% if CLEAN_WORK %}
        {% if DO_NATIVE and DO_REGRID %}
make-timeseries-regrid-{{ TIME_PER_B_SLICE }}<regrid> & make-timeseries-native-{{ TIME_PER_B_SLICE }}<native> & REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_A_SLICE }}
        {% elif DO_NATIVE %}
make-timeseries-native-{{ TIME_PER_B_SLICE }}<native> & REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_A_SLICE }}
        {% elif DO_REGRID %}
make-timeseries-regrid-{{ TIME_PER_B_SLICE }}<regrid> & REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_A_SLICE }}
        {% endif %}
REMAP-PP-COMPONENTS-{{ TIME_PER_B_SLICE }}:succeed-all => clean-shards-{{ TIME_PER_B_SLICE }}
    {% endif %}
"""
{% endif %}

[runtime]
    # default config for all tasks
    [[root]]
        init-script = """
            module load epmt
            module list
            epmt check
"""
        env-script = """
            eval $(rose task-env)
            env
"""
        script = rose task-run --verbose
        {# retries don't make sense yet while testing as they will just delay the failures #}
        {# execution retry delays = PT1M, PT5M, PT10M                                      #}
        [[[directives]]]
            --time=1:00:00
        [[[events]]]
            mail events = startup shutdown aborted timeout stalled inactivity
            submission timeout = P1D

    [[pp-starter]]
        [[[environment]]]
            targetFile = {{ HISTORY_DIR }}/YYYYMMDD.nc.tar

    [[STAGE-HISTORY]]
        pre-script = module load gcp hsm/test
        [[[directives]]]
            --time=8:00:00
    [[stage-history]]
        inherit = STAGE-HISTORY
        [[[environment]]]
            historyDir = {{ HISTORY_DIR }}
            ptmpDir = {{ PTMP_DIR }}
{% if HISTORY_DIR_REFINED is defined %}
    [[stage-history-refined]]
        inherit = STAGE-HISTORY
        script = rose task-run --verbose --app-key stage-history
        post-script = """
        """
        [[[environment]]]
            historyDir = {{ HISTORY_DIR_REFINED }}
            ptmpDir = {{ PTMP_DIR }}
    [[stage-history-refined-link]]
        script = """
            {# a disagreemable workaround to use PTMP as a data input location #}
            {# assumes no name collisions, and pollutes PTMP                   #}
            set -x
            cd {{ PTMP_DIR }}/{{ HISTORY_DIR }}/$(cylc date --template CCYYMMDD).nc
            ln -f {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}/$(cylc date --template CCYYMMDD).nc/*.nc .
        """
{% endif %}

{% if DO_REFINEDIAG or DO_PREANALYSIS %}
    [[PRE-ANALYSIS]]
        pre-script = """
            env
            set -x
            module load gcp/test
            module load fre/test
            mkdir -p $work $tempCache $refineDiagDir
            hsmget -v -t -a $histDir -p {{ PTMP_DIR }}/$histDir -w $work $hsmdate\/*
            cd $work/$hsmdate
            ls
        """
        [[[environment]]]
            name = {{ EXPERIMENT }}
            rtsxml = no-more-xml
            work = $TMPDIR/work
            tempCache = $TMPDIR/tempCache
            root = $CYLC_WORKFLOW_RUN_DIR
            archive = is-this-needed
            scriptName = $CYLC_TASK_LOG_DIR/job
            oname = $(cylc date --template CCYYMMDD)
            hsmdate = $oname.nc
            ptmpDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}
            histDir = {{ HISTORY_DIR }}
            platform = {{ PLATFORM }}
            target = {{ TARGET }}
            segment_months = {{ TIME_PER_HISTORY_SEGMENT }}
            basedate = is-this-needed
            gridspec = {{ PP_GRID_SPEC }}
            refineDiagDir = $TMPDIR/history_refineDiag/$hsmdate
{% endif %}
{% if DO_REFINEDIAG %}
    [[REFINE-DIAG]]
        inherit = PRE-ANALYSIS
        post-script = """
            cd $refineDiagDir
            if ls *nc; then
                refinedCount=$(ls -1 *nc | wc -l)
            else
                refinedCount=0
            fi
            if [[ $refinedCount > 0 ]]; then
                for file in $(ls -1 *nc); do
                    list_ncvars.csh -st01234 $file |& tee $CYLC_WORKFLOW_SHARE_DIR/refineDiag.log
                done
            else
                echo ERROR: RefineDiag script did not create any NetCDF files as it was expected to do
                exit 1
            fi
            if [[ -f {{ HISTORY_DIR_REFINED }}/$oname.nc.tar ]]; then
                hsmget -v -t -a {{ HISTORY_DIR_REFINED }} -p {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }} -w $TMPDIR/modify_refineDiag $hsmdate/\*
                mv -f * $TMPDIR/modify_refineDiag
                mv -f $TMPDIR/modify_refineDiag/* .
                rm -rf $TMPDIR/modify_refineDiag
            fi
            hsmput -v -t -s tar -a {{ HISTORY_DIR_REFINED }} -p {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }} -w $TMPDIR/history_refineDiag $hsmdate
        """
{# The following section executes refineDiag tasks, whether single or multiple refineDiag paths are given #}
{# Create a 'macro' function to reduce code repeat #}
    {% macro exec_refine(script_name) -%}
            inherit = REFINE-DIAG
            script = """
                ls
                echo NOTE: About to source user script
                if csh {{ script_name }}; then
                    echo NOTE: User script exited normally
                else
                    echo ERROR: User script got an error status $?
                    exit 1
                fi  
            """ 
    {%- endmacro %}        
{# Use the 'split' function to transform string into an iterable list, including of length 1 #}
    {% set refineDiag_scripts = REFINEDIAG_SCRIPTS.split(' ') %}
    {% for refineDiag_path in refineDiag_scripts %}
            [[refineDiag-{{ refineDiag_path[refineDiag_path.rfind('/')+1:refineDiag_path.rfind('.')] }}]]
        {{ exec_refine(refineDiag_path) }}
    {% endfor %}
{% endif %}

{% if DO_PREANALYSIS and PREANALYSIS_SCRIPT is defined %}
    {% set preanalysis_name = PREANALYSIS_SCRIPT[PREANALYSIS_SCRIPT.rfind('/')+1:PREANALYSIS_SCRIPT.rfind('.')] %}
    [[preAnalysis-{{ preanalysis_name }}]]
        inherit = PRE-ANALYSIS
        script = """
            ls
            echo NOTE: About to source user script
            if csh {{ PREANALYSIS_SCRIPT }}; then
                echo NOTE: User script exited normally
            else
                echo ERROR: User script got an error status $?
                exit 1
            fi
        """
{% endif %}

    [[SPLIT-NETCDF]]
        pre-script = module load cdo nco && mkdir -p $outputDir
        script = rose task-run --verbose --app-key split-netcdf
        [[[environment]]]
            date = $CYLC_TASK_CYCLE_POINT

{% if DO_NATIVE %}
    [[SPLIT-NETCDF-NATIVE]]
        inherit = SPLIT-NETCDF
        [[[environment]]]
            inputDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}/$(cylc date --template CCYYMMDD).nc
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[SPLIT-NETCDF-REGRID]]
        inherit = SPLIT-NETCDF
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[split-netcdf-native<native>]]
        inherit = SPLIT-NETCDF-NATIVE
    {% if DO_STATICS %}
    [[split-netcdf-native<native_static>]]
        inherit = SPLIT-NETCDF-NATIVE
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %} 
    [[split-netcdf-regrid<regrid>]]
        inherit = SPLIT-NETCDF-REGRID
    {% if DO_STATICS %}
    [[split-netcdf-regrid<regrid_static>]]
        inherit = SPLIT-NETCDF-REGRID
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[RENAME-SPLIT-TO-PP]]
        pre-script = module load netcdf-c cdo && mkdir -p $outputDir
        script = rose task-run --verbose --app-key rename-split-to-pp

{% if DO_NATIVE %}
    [[RENAME-SPLIT-TO-PP-NATIVE]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[RENAME-SPLIT-TO-PP-REGRID]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[rename-split-to-pp-native<native>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE
    {% if DO_STATICS %} 
    [[rename-split-to-pp-native<native_static>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %} 
    [[rename-split-to-pp-regrid<regrid>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID
    {% if DO_STATICS %}
    [[rename-split-to-pp-regrid<regrid_static>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[REMAP-PP-COMPONENTS]]
        pre-script = module load cdo gcp/test && mkdir -p $outputDir
        script = rose task-run --verbose --app-key remap-pp-components
        [[[directives]]]
            --time=8:00:00
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards
            outputDir = {{ PP_DIR }}
            components = $CYLC_TASK_PARAM_component
    [[REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            begin = $(cylc date --offset=-{{ TIME_PER_A_SLICE | subtract_durations(TIME_PER_HISTORY_SEGMENT) }})
            currentChunk = {{ TIME_PER_A_SLICE }}
    [[remap-pp-components-{{ TIME_PER_A_SLICE }}<component>]]
        inherit = REMAP-PP-COMPONENTS-{{ TIME_PER_A_SLICE }}
{% if DO_SECONDARY_PP %}
    [[REMAP-PP-COMPONENTS-{{ TIME_PER_B_SLICE }}]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            begin = $(cylc date --offset=-{{ TIME_PER_B_SLICE | subtract_durations(TIME_PER_HISTORY_SEGMENT) }})
            currentChunk = {{ TIME_PER_B_SLICE }}
    [[remap-pp-components-{{ TIME_PER_B_SLICE }}<component>]]
        inherit = REMAP-PP-COMPONENTS-{{ TIME_PER_B_SLICE }}
{% endif %}

{% if DO_STATICS %}
    [[remap-pp-components-static]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            begin = $CYLC_TASK_CYCLE_POINT
            currentChunk = P0Y
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/pp
            components = {{ PP_COMPONENTS }}
{% endif %}

    [[MAKE-TIMESERIES]]
        pre-script = module load cdo && mkdir -p $outputDir
        script = rose task-run --verbose --app-key make-timeseries
        [[[environment]]]
            fail_ok_components = grid_spec lumip_Lyr lumip_Lyr_crp lumip_Lyr_psl lumip_Lyr_pst

{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

    [[MAKE-TIMESERIES-{{ TIME_PER_A_SLICE }}]]
        [[[environment]]]
            begin = $(cylc date --offset=-{{ TIME_PER_A_SLICE | subtract_durations(TIME_PER_HISTORY_SEGMENT) }})
            inputChunk = {{ TIME_PER_HISTORY_SEGMENT }}
            outputChunk = {{ TIME_PER_A_SLICE }}
{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE-{{ TIME_PER_A_SLICE }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ TIME_PER_A_SLICE }}
    [[make-timeseries-native-{{ TIME_PER_A_SLICE }}<native>]]
        inherit = MAKE-TIMESERIES-NATIVE-{{ TIME_PER_A_SLICE }}
{% endif %}
{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID-{{ TIME_PER_A_SLICE }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ TIME_PER_A_SLICE }}
    [[make-timeseries-regrid-{{ TIME_PER_A_SLICE }}<regrid>]]
        inherit = MAKE-TIMESERIES-REGRID-{{ TIME_PER_A_SLICE }}
{% endif %}

{% if DO_SECONDARY_PP %}
    [[MAKE-TIMESERIES-{{ TIME_PER_B_SLICE }}]]
        [[[environment]]]
            begin = $(cylc date --offset=-{{ TIME_PER_B_SLICE | subtract_durations(TIME_PER_HISTORY_SEGMENT) }})
            inputChunk = {{ TIME_PER_A_SLICE }}
            outputChunk = {{ TIME_PER_B_SLICE }}
    {% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE-{{ TIME_PER_B_SLICE }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ TIME_PER_B_SLICE }}
    [[make-timeseries-native-{{ TIME_PER_B_SLICE }}<native>]]
        inherit = MAKE-TIMESERIES-NATIVE-{{ TIME_PER_B_SLICE }}
    {% endif %}

    {% if DO_REGRID %} 
    [[MAKE-TIMESERIES-REGRID-{{ TIME_PER_B_SLICE }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ TIME_PER_B_SLICE }}
    [[make-timeseries-regrid-{{ TIME_PER_B_SLICE }}<regrid>]]
        inherit = MAKE-TIMESERIES-REGRID-{{ TIME_PER_B_SLICE }}
    {% endif %}
{% endif %}

{% if DO_REGRID %} 
    [[REGRID-XY]]
        pre-script = module load fre/test && mkdir -p $outputDir
        script = rose task-run --verbose --app-key regrid-xy
        [[[environment]]]
            inputDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}/$(cylc date --template CCYYMMDD).nc
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            begin = $CYLC_TASK_CYCLE_POINT
            fregridRemapDir = $CYLC_WORKFLOW_SHARE_DIR/fregrid-remap-files
            component = $CYLC_TASK_PARAM_regrid
            gridSpec = {{ PP_GRID_SPEC }}
            defaultxyInterp = {{ PP_DEFAULT_XYINTERP }}
    [[regrid-xy<regrid>]]
        inherit = REGRID-XY
    {% if DO_STATICS %}
    [[regrid-xy<regrid_static>]]
        inherit = REGRID-XY
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

{% if DO_STATICS %}
    [[combine-statics]]
        pre-script = module load cdo && mkdir -p $outputDir
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp
            outputDir = {{ PP_DIR }}
{% endif %}

    [[mdtf]]
        pre-script = mkdir -p $MDTF_TMPDIR
        [[[environment]]]
            MDTF_TMPDIR = $CYLC_WORKFLOW_SHARE_DIR/mdtf

    [[CLEAN]]
        pre-script = "set -x"

{% if DO_REGRID %}
    [[clean-history-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy"
{% endif %}

{% if DO_STATICS %}
    [[clean-pp-statics]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/pp"
{% endif %}
{% if DO_NATIVE %}
    [[clean-split-native]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native"
{% endif %}
{% if DO_REGRID %}
    [[clean-split-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy"
{% endif %}

{% if DO_STATICS %}
    [[clean-shards-static]]
        inherit = CLEAN
        script = """
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/P0Y
    {% if DO_REGRID %}
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/P0Y
    {% endif %}
        """
{% endif %}

    [[clean-shards-{{ TIME_PER_HISTORY_SEGMENT }}]]
        inherit = CLEAN
        script = """
{% for SEGMENT in range(0, HISTORY_SEGMENTS_PER_SLICE) %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_HISTORY_SEGMENT }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_HISTORY_SEGMENT }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc" -delete
    {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_HISTORY_SEGMENT }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_HISTORY_SEGMENT }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc" -delete
    {% endif %}
{% endfor %}
        """

    [[clean-shards-{{ TIME_PER_A_SLICE }}]]
        inherit = CLEAN
        script = """
{% if DO_SECONDARY_PP %}
    {% for SLICE in range(0, A_SLICES_PER_B_SLICE) %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_A_SLICE | multiply_duration(-SLICE) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_A_SLICE | multiply_duration(-SLICE) }})*.nc" -delete
        {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_A_SLICE | multiply_duration(-SLICE) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY --offset={{ TIME_PER_A_SLICE | multiply_duration(-SLICE) }})*.nc" -delete
        {% endif %}
    {% endfor %}
{% else %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc" -delete
    {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_A_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc" -delete
    {% endif %}
{% endif %}
        """

{% if DO_SECONDARY_PP %}
    [[clean-shards-{{ TIME_PER_B_SLICE }}]]
        inherit = CLEAN
        script = """
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_B_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ TIME_PER_B_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc" -delete
    {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_B_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ TIME_PER_B_SLICE }} -type f -name "*.*-$(cylc date --template CCYY)*.nc" -delete
    {% endif %}
        """
{% endif %}

# Site-specific settings
{% include 'site/' ~ SITE ~ '.cylc' %}
