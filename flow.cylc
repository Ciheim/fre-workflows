#!jinja2

{# things written between hash and single braces is a Jinja comment. #}
{# Jinja code between single braces is run.                          #}
{# Jinja code with two braces is printed.                            #}

{# The site-specific file (stored in site/ subdir) is included at the end of this file.	              #}
{# (Probably, we should use similar mechanisms where sensible, e.g. for shared items among workflows) #}
{% set SITE = 'generic' %}

{# Calculate the number of history segments per a-chunk #}
{% set HIST_SEGMENTS_PER_CHUNK_A = (PP_CHUNK_A | duration_as('s') / HISTORY_SEGMENT | duration_as('s')) | int %}

{# Calculate the number of a-chunks per b-chunk (if desired) #}
{% set DO_SECONDARY_PP = False %}
{% if PP_CHUNK_B is defined and PP_CHUNK_B != PP_CHUNK_A %}
    {% set CHUNK_AS_PER_CHUNK_B = (PP_CHUNK_B | duration_as('s') / PP_CHUNK_A | duration_as('s')) | int %}
    {% set DO_SECONDARY_PP = True %}
{% endif %}

[meta]
    title = "Postprocessing Example 1"
    description = """
Postprocessing example that includes Bronx-like functionality,
"""
    URL = https://gitlab.gfdl.noaa.gov/fre2/workflows/postprocessing

[scheduler]
    {# Implicit tasks are tasks without explicit runtime definitions in [runtime], often typos. #}
    {# (For prototyping and graphing, change this to True.)                                     #}
    allow implicit tasks = False

    {# Configure the directories and files to be included in the remote file installation #}
    install = app/*, bin/*, etc/*, lib/*
    UTC mode = True

[task parameters]
{# The task parameters (except for component) depend on configuration in Rose apps,                            #}
{# so custom Jinja triggers are used to form the lists. Cylc and custom Jinja triggers have these rules:       #}
{# 1. Triggers live in Jinja2Filters/ and must be python						       #}
{# 2. The trigger filename must be <trigger-name>.py							       #}
{# 3. In the file, trigger must be defined as a function with the same name				       #}
{# 4. First argument is passed through as a pipe, and the rest are passed through in the trigger arguments.    #}
{# More info:												       #}
{# The python loaded within Cylc has access to some useful Cylc utilities (e.g. metomi.isodatetime.parsers).   #}
{# For development/testing, use "module load conda; conda activate cylc". Then the Cylc python will be loaded. #}
{% set REGRID  =  "regrid-xy" | form_task_parameters('temporal', PP_COMPONENTS) %}
{% set REGRID_STATIC  =  "regrid-xy" | form_task_parameters('static', PP_COMPONENTS) %}
{% set DO_REGRID = REGRID|length %}
{% if DO_REGRID %}
    regrid = {{ REGRID }}
    {% if DO_STATICS %}
    regrid_static = {{ REGRID_STATIC }}
    {% endif %}
{% endif %}

{% set NATIVE  =  "native" | form_task_parameters('temporal', PP_COMPONENTS) %}
{% set NATIVE_STATIC  =  "native" | form_task_parameters('static', PP_COMPONENTS) %}
{% set DO_NATIVE = NATIVE|length %}
{% if DO_NATIVE %}
    native = {{ NATIVE }}
    {% if DO_STATICS %}
    native_static = {{ NATIVE_STATIC }}
    {% endif %}
{% endif %}

    {# Standard Jinja2 triggers are also available (e.g. "replace") #}
    component  =    {{ PP_COMPONENTS | replace(' ', ', ') }}

[scheduling]
    initial cycle point = {{ PP_START }}
    final cycle point = {{ PP_STOP }}
    # max number of active cycle points (default 5)
    runahead limit = P10
    {# Graph strings are organized by recurrence interval-- when to run the tasks.    #}
    {# Currently, we use 4 intervals: every history-file segment, once (for statics), #}
    {# every chunk-a, and every chunk-b.                                              #}
    [[graph]]
{% if DO_ANALYSIS_ONLY %}
    {% if DO_SECONDARY_PP %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
    {% else %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
    {% endif %}
{% else %}
        #
        # Recurrence interval: every history-file segment
        #
        {{ HISTORY_SEGMENT }} = """
{# Within a recurrence interval, task dependencies are specified with => (depends on), & (and), and | (or). #}
{# Tasks in a dependency can be single tasks, task families (by convention, in all caps),		    #}
{# or "ensembles" expanded by the parameters above.                                                         #}

{# All tasks in the STAGE-HISTORY family (staging history and staging history-refined) are started #}
{# once the pp-starter task succeeds.                                                              #}
pp-starter => STAGE-HISTORY

{# Jinja is useful to include or exclude parts of the configuration. In this case, the lines between              #}
{# if DO_REFINEDIAG and endif are used or not used, depending on the value of DO_REFINEDIAG (in rose-suite.conf). #}
{# All template variables in rose-suite.conf are available as Jinja variables.					  #}
{# If refineDiag generation is desired (DO_REFINEDIAG is True), then add these two task dependencies:		  #}
{# 1. All tasks in the REFINE-DIAG task family are started once the stage-history task succeeds.		  #}
{# 2. stage-history-refined task is started once all the refineDiag tasks succeed.                                #}
    {% if DO_REFINEDIAG %}
stage-history => REFINE-DIAG
REFINE-DIAG:succeed-all => stage-history-refined
    {% endif %}

{# If preAnalysis desired (vitals calculations is canonical case), start all PRE-ANALYSIS tasks when stage-history succeeds. #}
    {% if DO_PREANALYSIS %}
stage-history => PRE-ANALYSIS
    {% endif %}

{# If task families are on the left side of the => then a qualifier must be used (e.g. :succeed-all)                     #}
{# The angle brackets define the "ensemble" axis, the task paramaters defined above.					 #}
{# The next two lines set the major processing for the native and regrid (horizontal regridding) lists of history files. #}
{# Each history file to be regridded should be regridded once staging is done; then should be split and cataloged	 #}
{# (into a standard shards directory set by ISO8601 frequencies ).						 #}
{# Each history file needed for native grid processing is similar, except skipping the regridding.                       #}
    {% if DO_REGRID %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid> => split-netcdf-regrid<regrid> => rename-split-to-pp-regrid<regrid>
    {% endif %}

    {% if DO_NATIVE %}
STAGE-HISTORY:succeed-all =>                      split-netcdf-native<native> => rename-split-to-pp-native<native>
    {% endif %}

{# If HISTORY_DIR_REFINED is set, then use the next 3 lines.                                                                #}
{# After all staging is done, then hard link the refined history files to the history file location (not a great solution). #}
{# Regridding and splitting native history files should not start until the history-refined output is available.            #}
    {% if HISTORY_DIR_REFINED is defined %}
STAGE-HISTORY:succeed-all  => stage-history-refined-link
        {% if DO_REGRID %}
stage-history-refined-link => regrid-xy<regrid>
        {% endif %}
        {% if DO_NATIVE %}
stage-history-refined-link => split-netcdf-native<native>
        {% endif %}
    {% endif %}

{# If work-dir cleaning is desired, then remove what should now be safe to remove.                                 #}
{# Once regridded history files are split, then the regridded history files can be removed.			   #}
{# Once the split (regridded and native) files are cataloged, then the (not-cataloged) split files can be removed. #}
    {% if CLEAN_WORK %}
        {% if DO_REGRID %}
split-netcdf-regrid<regrid>       => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid> => clean-split-regrid-xy
        {% endif %}
        {% if DO_NATIVE %}
rename-split-to-pp-native<native> => clean-split-native
        {% endif %}
    {% endif %}
"""


        #
        # Recurrence interval R1: run only once. useful for statics.
        #
        R1 = """
{# The static processing is similar to the "every history segment" processing, except uses different history file lists. #}
pp-starter => STAGE-HISTORY
    {% if DO_STATICS %}
        {% if DO_REGRID %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid_static> => split-netcdf-regrid<regrid_static> => rename-split-to-pp-regrid<regrid_static>
        {% endif %}
        {% if DO_NATIVE %}
STAGE-HISTORY:succeed-all =>                             split-netcdf-native<native_static> => rename-split-to-pp-native<native_static>
        {% endif %}
{# After cataloging the regridded and native statics, remap them to pp components as desired #}
        {% if DO_NATIVE and DO_REGRID %}
rename-split-to-pp-regrid<regrid_static> & rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
        {% elif DO_NATIVE %}
rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
        {% elif DO_REGRID %}
rename-split-to-pp-regrid<regrid_static> => remap-pp-components-static => combine-statics
        {% endif %}
    {% endif %}

{# Similarly, if the history-refined is used, then don't process until the history-refined staging is done. #}
    {% if HISTORY_DIR_REFINED is defined %}
STAGE-HISTORY:succeed-all => stage-history-refined-link
        {% if DO_STATICS %}
            {% if DO_REGRID %}
stage-history-refined-link => regrid-xy<regrid_static>
            {% endif %}
            {% if DO_NATIVE %}
stage-history-refined-link => split-netcdf-native<native_static>
            {% endif %}
        {% endif %}
    {% endif %}

{# If work-dir cleaning is set, then remove what should now be safe to remove. #}
    {% if CLEAN_WORK and DO_STATICS %}
        {% if DO_REGRID %}
split-netcdf-regrid<regrid_static> => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid_static> => clean-split-regrid-xy
        {% endif %}
        {% if DO_NATIVE %}
rename-split-to-pp-native<native_static> => clean-split-native
        {% endif %}
remap-pp-components-static => clean-shards-static
combine-statics => clean-pp-statics
    {% endif %}
"""


        #
        # Recurrence interval: every CHUNK-A
        #
        {# Run the tasks to process CHUNK-A every CHUNK-A, starting after PP_CHUNK_A #}
        +{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }}/{{ PP_CHUNK_A }} = """

{# Tasks can be split over multiple lines if the subsequent ones begin with =>, &, or |                   #}
{# The make-timeseries tasks for CHUNK-A depend on all segment processing for the time period succeeding. #}
{# This Jinja for loop expands to do this.                                                                #}
    {% if DO_REGRID %}
rename-split-to-pp-regrid<regrid>
        {% for SEGMENT in range(1, HIST_SEGMENTS_PER_CHUNK_A) %}
& rename-split-to-pp-regrid<regrid>[{{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }}]
        {% endfor %}
=> make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>
    {% endif %}

    {% if DO_NATIVE %}
rename-split-to-pp-native<native>
        {% for SEGMENT in range(1, HIST_SEGMENTS_PER_CHUNK_A) %}
& rename-split-to-pp-native<native>[{{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }}]
        {% endfor %}
=> make-timeseries-native-{{ PP_CHUNK_A }}<native>
    {% endif %}

    {% if DO_REGRID %}
        {% set form_remap_dep_PP_CHUNK_A_regrid  =  "regrid-xy" | form_remap_dep('temporal', PP_CHUNK_A, PP_COMPONENTS) %}
{{  form_remap_dep_PP_CHUNK_A_regrid  }}
    {% endif %}

    {% if DO_NATIVE %}
        {% set form_remap_dep_PP_CHUNK_A_native  =  "native" | form_remap_dep('temporal', PP_CHUNK_A, PP_COMPONENTS) %}
{{  form_remap_dep_PP_CHUNK_A_native  }}
    {% endif %}

{# If work-dir cleaning is desired, and (chunk A is larger than the history segment, or, only one pp size is specified), remove (prerequisite) history shards. #}
{# If instead chunk A is identical to the history segment, then do not remove the shards, as they haven't be saved (remapped) yet.                              #}
    {% if CLEAN_WORK and PP_CHUNK_A != HISTORY_SEGMENT %}

        {% if DO_NATIVE and DO_REGRID %}
make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid> & make-timeseries-native-{{ PP_CHUNK_A }}<native> & REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ HISTORY_SEGMENT }}
        {% elif DO_NATIVE %}
make-timeseries-native-{{ PP_CHUNK_A }}<native> & REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ HISTORY_SEGMENT }}
        {% elif DO_REGRID %}
make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid> & REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ HISTORY_SEGMENT }}
        {% endif %}

    {% endif %}

{# If MDTF is requested, then run it after all pp components have finished #}
    {% if DO_MDTF %}
REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => mdtf
    {% endif %}
"""


#
# Recurrence interval: every CHUNK-B
#
{# If only one pp chunk is used, then skip the CHUNK-B processing. #}
    {% if DO_SECONDARY_PP %}
        {# Run the tasks to process CHUNK-B every CHUNK-B, starting after CHUNK-B time #}
        +{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }}/{{ PP_CHUNK_B }} = """

{# The make-timeseries tasks for CHUNK-B depend on all CHUNK-A processing for the time period succeeding. #}
        {% if DO_REGRID %}
make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>
            {% for CHUNK in range(1, CHUNK_AS_PER_CHUNK_B) %}
& make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>[{{ PP_CHUNK_A | multiply_duration(-CHUNK)}}]
            {% endfor %}
=> make-timeseries-regrid-{{ PP_CHUNK_B }}<regrid>
        {% endif %}


        {% if DO_NATIVE %}
make-timeseries-native-{{ PP_CHUNK_A }}<native>
            {% for CHUNK in range(1, CHUNK_AS_PER_CHUNK_B) %}
& make-timeseries-native-{{ PP_CHUNK_A }}<native>[{{ PP_CHUNK_A | multiply_duration(-CHUNK)}}]
            {% endfor %}
=> make-timeseries-native-{{ PP_CHUNK_B }}<native>
        {% endif %}

{# Generate the per-component make-timeseries => remap-pp-component tasks using Jinja trigger form_remap_dep #}
{# Throw validation exception if PP_CHUNK_B is not in rose-app.conf                                          #}
        {% if DO_REGRID %}
            {% set form_remap_dep_PP_CHUNK_B_regrid  =  "regrid-xy" | form_remap_dep('temporal', PP_CHUNK_B, PP_COMPONENTS) %}
{{ form_remap_dep_PP_CHUNK_B_regrid }}
        {% endif %}

        {% if DO_NATIVE %}
            {% set form_remap_dep_PP_CHUNK_B_native  =  "native" | form_remap_dep('temporal', PP_CHUNK_B, PP_COMPONENTS) %}
{{ form_remap_dep_PP_CHUNK_B_native }}
        {% endif %}

{# If work-dir cleaning is desired, remove CHUNK-A shards once CHUNK-B timeseries are created, #}
{# and remove CHUNK-B shards once the final products are saved.                                #}
        {% if CLEAN_WORK %}
            {% if DO_NATIVE and DO_REGRID %}
make-timeseries-regrid-{{ PP_CHUNK_B }}<regrid> & make-timeseries-native-{{ PP_CHUNK_B }}<native> & REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ PP_CHUNK_A }}
            {% elif DO_NATIVE %}
make-timeseries-native-{{ PP_CHUNK_B }}<native> & REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ PP_CHUNK_A }}
            {% elif DO_REGRID %}
make-timeseries-regrid-{{ PP_CHUNK_B }}<regrid> & REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ PP_CHUNK_A }}
            {% endif %}
REMAP-PP-COMPONENTS-{{ PP_CHUNK_B }}:succeed-all => clean-shards-{{ PP_CHUNK_B }}
        {% endif %}
"""
    {% endif %}

#
# Recurrence intervals for analysis tasks
#
    {% if DO_ANALYSIS %}
        {% if DO_SECONDARY_PP %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
        {% else %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
        {% endif %}
    {% endif %}

{% endif %}

[runtime]
    # default config for all tasks
    [[root]]
        script = rose task-run --verbose
        {# retries don't make sense yet while testing as they will just delay the failures #}
        {# execution retry delays = PT1M, PT5M, PT10M                                      #}
        # Set default time limit to 4 hours
        execution time limit = PT4H
        [[[events]]]
            mail events = startup shutdown aborted timeout stalled inactivity
            submission timeout = P1D

    [[pp-starter]]
        [[[environment]]]
            targetFile = {{ HISTORY_DIR }}/YYYYMMDD.nc.tar

    [[STAGE-HISTORY]]
        # Increase time limit for staging jobs to 8 hours
         execution time limit = PT8H
    [[stage-history]]
        inherit = STAGE-HISTORY
        [[[environment]]]
            historyDir = {{ HISTORY_DIR }}
            ptmpDir = {{ PTMP_DIR }}
{% if HISTORY_DIR_REFINED is defined %}
    [[stage-history-refined]]
        inherit = STAGE-HISTORY
        script = rose task-run --verbose --app-key stage-history
        post-script = """
        """
        [[[environment]]]
            historyDir = {{ HISTORY_DIR_REFINED }}
            ptmpDir = {{ PTMP_DIR }}
    [[stage-history-refined-link]]
        script = """
            {# a disagreeable workaround to use PTMP as a data input location #}
            {# assumes no name collisions, and pollutes PTMP                   #}
            set -x
            cd {{ PTMP_DIR }}/{{ HISTORY_DIR }}/$(cylc cycle-point --template CCYYMMDD).nc
            ln -f {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}/$(cylc cycle-point --template CCYYMMDD).nc/*.nc .
        """
{% endif %}

{% if DO_REFINEDIAG or DO_PREANALYSIS %}
    [[PRE-ANALYSIS]]
        [[[environment]]]
            name = {{ EXPERIMENT }}
            rtsxml = no-more-xml
            work = $TMPDIR/work
            tempCache = $TMPDIR/tempCache
            root = $CYLC_WORKFLOW_RUN_DIR
            archive = is-this-needed
            scriptName = $CYLC_TASK_LOG_DIR/job
            oname = $(cylc cycle-point --template CCYYMMDD)
            hsmdate = $oname.nc
            ptmpDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}
            histDir = {{ HISTORY_DIR }}
            platform = {{ PLATFORM }}
            target = {{ TARGET }}
            segment_months = {{ HISTORY_SEGMENT }}
            basedate = is-this-needed
            gridspec = {{ PP_GRID_SPEC }}
            refineDiagDir = $TMPDIR/history_refineDiag/$hsmdate
{% endif %}
{% if DO_REFINEDIAG %}
    [[REFINE-DIAG]]
        inherit = PRE-ANALYSIS
{# The following section executes refineDiag tasks, whether single or multiple refineDiag paths are given #}
{# Create a 'macro' function to reduce code repeat #}
    {% macro exec_refine(script_name) -%}
            inherit = REFINE-DIAG
            script = """
                ls
                echo NOTE: About to source user script
                if csh {{ script_name }}; then
                    echo NOTE: User script exited normally
                else
                    echo ERROR: User script got an error status $?
                    exit 1
                fi
            """
    {%- endmacro %}
{# Use the 'split' function to transform string into an iterable list, including of length 1 #}
    {% set refineDiag_scripts = REFINEDIAG_SCRIPTS.split(' ') %}
    {% for refineDiag_path in refineDiag_scripts %}
            [[refineDiag-{{ refineDiag_path[refineDiag_path.rfind('/')+1:refineDiag_path.rfind('.')] }}]]
        {{ exec_refine(refineDiag_path) }}
    {% endfor %}
{% endif %}

{% if DO_PREANALYSIS and PREANALYSIS_SCRIPT is defined %}
    {% set preanalysis_name = PREANALYSIS_SCRIPT[PREANALYSIS_SCRIPT.rfind('/')+1:PREANALYSIS_SCRIPT.rfind('.')] %}
    [[preAnalysis-{{ preanalysis_name }}]]
        inherit = PRE-ANALYSIS
        script = """
            ls
            echo NOTE: About to source user script
            if csh {{ PREANALYSIS_SCRIPT }}; then
                echo NOTE: User script exited normally
            else
                echo ERROR: User script got an error status $?
                exit 1
            fi
        """
{% endif %}

    [[SPLIT-NETCDF]]
        pre-script = module load cdo nco && mkdir -p $outputDir
        script = rose task-run --verbose --app-key split-netcdf
        [[[environment]]]
            date = $CYLC_TASK_CYCLE_POINT

{% if DO_NATIVE %}
    [[SPLIT-NETCDF-NATIVE]]
        inherit = SPLIT-NETCDF
        [[[environment]]]
            inputDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}/$(cylc cycle-point --template CCYYMMDD).nc
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[SPLIT-NETCDF-REGRID]]
        inherit = SPLIT-NETCDF
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[split-netcdf-native<native>]]
        inherit = SPLIT-NETCDF-NATIVE
    {% if DO_STATICS %}
    [[split-netcdf-native<native_static>]]
        inherit = SPLIT-NETCDF-NATIVE
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[split-netcdf-regrid<regrid>]]
        inherit = SPLIT-NETCDF-REGRID
    {% if DO_STATICS %}
    [[split-netcdf-regrid<regrid_static>]]
        inherit = SPLIT-NETCDF-REGRID
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[RENAME-SPLIT-TO-PP]]
        pre-script = module load netcdf-c cdo && mkdir -p $outputDir
        script = rose task-run --verbose --app-key rename-split-to-pp

{% if DO_NATIVE %}
    [[RENAME-SPLIT-TO-PP-NATIVE]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[RENAME-SPLIT-TO-PP-REGRID]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[rename-split-to-pp-native<native>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE
    {% if DO_STATICS %}
    [[rename-split-to-pp-native<native_static>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[rename-split-to-pp-regrid<regrid>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID
    {% if DO_STATICS %}
    [[rename-split-to-pp-regrid<regrid_static>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[REMAP-PP-COMPONENTS]]
        pre-script = module load cdo gcp/test && mkdir -p $outputDir
        script = rose task-run --verbose --app-key remap-pp-components
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards
            outputDir = {{ PP_DIR }}
            components = $CYLC_TASK_PARAM_component
    [[REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }})
            currentChunk = {{ PP_CHUNK_A }}
    [[remap-pp-components-{{ PP_CHUNK_A }}<component>]]
        inherit = REMAP-PP-COMPONENTS-{{ PP_CHUNK_A }}
{% if DO_SECONDARY_PP %}
    [[REMAP-PP-COMPONENTS-{{ PP_CHUNK_B }}]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }})
            currentChunk = {{ PP_CHUNK_B }}
    [[remap-pp-components-{{ PP_CHUNK_B }}<component>]]
        inherit = REMAP-PP-COMPONENTS-{{ PP_CHUNK_B }}
{% endif %}

{% if DO_STATICS %}
    [[remap-pp-components-static]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            begin = $CYLC_TASK_CYCLE_POINT
            currentChunk = P0Y
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/pp
            components = {{ PP_COMPONENTS }}
{% endif %}

    [[MAKE-TIMESERIES]]
        pre-script = module load cdo && mkdir -p $outputDir
        script = rose task-run --verbose --app-key make-timeseries
        [[[environment]]]
            fail_ok_components = grid_spec lumip_Lyr lumip_Lyr_crp lumip_Lyr_psl lumip_Lyr_pst

{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

    [[MAKE-TIMESERIES-{{ PP_CHUNK_A }}]]
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }})
            inputChunk = {{ HISTORY_SEGMENT }}
            outputChunk = {{ PP_CHUNK_A }}
{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_A }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ PP_CHUNK_A }}
    [[make-timeseries-native-{{ PP_CHUNK_A }}<native>]]
        inherit = MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_A }}
{% endif %}
{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_A }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ PP_CHUNK_A }}
    [[make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>]]
        inherit = MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_A }}
{% endif %}

{% if DO_SECONDARY_PP %}
    [[MAKE-TIMESERIES-{{ PP_CHUNK_B }}]]
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }})
            inputChunk = {{ PP_CHUNK_A }}
            outputChunk = {{ PP_CHUNK_B }}
    {% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_B }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ PP_CHUNK_B }}
    [[make-timeseries-native-{{ PP_CHUNK_B }}<native>]]
        inherit = MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_B }}
    {% endif %}

    {% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_B }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ PP_CHUNK_B }}
    [[make-timeseries-regrid-{{ PP_CHUNK_B }}<regrid>]]
        inherit = MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_B }}
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[REGRID-XY]]
        pre-script = module load fre/test && mkdir -p $outputDir
        script = rose task-run --verbose --app-key regrid-xy
        [[[environment]]]
            inputDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}/$(cylc cycle-point --template CCYYMMDD).nc
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            begin = $CYLC_TASK_CYCLE_POINT
            fregridRemapDir = $CYLC_WORKFLOW_SHARE_DIR/fregrid-remap-files
            component = $CYLC_TASK_PARAM_regrid
            gridSpec = {{ PP_GRID_SPEC }}
            defaultxyInterp = {{ PP_DEFAULT_XYINTERP }}
    [[regrid-xy<regrid>]]
        inherit = REGRID-XY
    {% if DO_STATICS %}
    [[regrid-xy<regrid_static>]]
        inherit = REGRID-XY
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

{% if DO_STATICS %}
    [[combine-statics]]
        pre-script = module load cdo && mkdir -p $outputDir
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp
            outputDir = {{ PP_DIR }}
{% endif %}

{% if DO_ANALYSIS %}
    [[ANALYSIS]]
        pre-script = """
            env
            mkdir -p $outputDir $out_dir
            rose task-run --verbose --app-key analysis
        """
        [[[environment]]]
            # internally-used vars
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/analysis-scripts
            FRE_ANALYSIS_HOME = /home/fms/local/opt/fre-analysis/test
            FRE_ANALYSIS_GIT_URL = file:///home/fms/local/opt/fre-analysis/git
            # fre-analysis template vars
            yr2 = $(cylc cycle-point --template=CCYY)
            out_dir = {{ ANALYSIS_DIR }}
            descriptor = {{ EXPERIMENT }}
            fremodule = fre/test
            WORKDIR = $TMPDIR/{{ EXPERIMENT }}/{{ PLATFORM }}-{{ TARGET }}/$CYLC_TASK_CYCLE_POINT
            hist_dir = {{ HISTORY_DIR }}
            gridspecfile = {{ PP_GRID_SPEC }}
    {% if DO_SECONDARY_PP %}
{{ 'per-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, False, DO_ANALYSIS) }}
{{ 'cumulative-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, False, DO_ANALYSIS) }}
{{ 'defined-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_B, False, DO_ANALYSIS) }}
    {% else %}
{{ 'per-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, False, DO_ANALYSIS) }}
{{ 'cumulative-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, False, DO_ANALYSIS) }}
{{ 'defined-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNK_A, False, DO_ANALYSIS) }}
    {% endif %}
{% endif %}

    [[mdtf]]
        pre-script = mkdir -p $MDTF_TMPDIR
        [[[environment]]]
            MDTF_TMPDIR = $CYLC_WORKFLOW_SHARE_DIR/mdtf

    [[CLEAN]]
        pre-script = "set -x"

{% if DO_REGRID %}
    [[clean-history-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy"
{% endif %}

{% if DO_STATICS %}
    [[clean-pp-statics]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/pp"
{% endif %}
{% if DO_NATIVE %}
    [[clean-split-native]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native"
{% endif %}
{% if DO_REGRID %}
    [[clean-split-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy"
{% endif %}

{% if DO_STATICS %}
    [[clean-shards-static]]
        inherit = CLEAN
        script = """
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/P0Y
    {% if DO_REGRID %}
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/P0Y
    {% endif %}
        """
{% endif %}

    [[clean-shards-{{ HISTORY_SEGMENT }}]]
        inherit = CLEAN
        script = """
{% for SEGMENT in range(0, HIST_SEGMENTS_PER_CHUNK_A) %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ HISTORY_SEGMENT }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ HISTORY_SEGMENT }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc" -delete
    {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ HISTORY_SEGMENT }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ HISTORY_SEGMENT }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc" -delete
    {% endif %}
{% endfor %}
        """

    [[clean-shards-{{ PP_CHUNK_A }}]]
        inherit = CLEAN
        script = """
{% if DO_SECONDARY_PP %}
    {% for CHUNK in range(0, CHUNK_AS_PER_CHUNK_B) %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ PP_CHUNK_A | multiply_duration(-CHUNK) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ PP_CHUNK_A | multiply_duration(-CHUNK) }})*.nc" -delete
        {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ PP_CHUNK_A | multiply_duration(-CHUNK) }})*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ PP_CHUNK_A | multiply_duration(-CHUNK) }})*.nc" -delete
        {% endif %}
    {% endfor %}
{% else %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -delete
    {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ PP_CHUNK_A }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -delete
    {% endif %}
{% endif %}
        """

{% if DO_SECONDARY_PP %}
    [[clean-shards-{{ PP_CHUNK_B }}]]
        inherit = CLEAN
        script = """
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ PP_CHUNK_B }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/*/*/*/{{ PP_CHUNK_B }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -delete
    {% if DO_REGRID %}
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ PP_CHUNK_B }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc"
            find $CYLC_WORKFLOW_SHARE_DIR/shards/regrid-xy/*/*/*/{{ PP_CHUNK_B }} -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -delete
    {% endif %}
        """
{% endif %}

# Site-specific settings
{% include 'site/' ~ SITE ~ '.cylc' %}
