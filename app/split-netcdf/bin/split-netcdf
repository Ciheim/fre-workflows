#!/bin/bash
set -euo pipefail
set -x

#
# Split NetCDF files by variable
#
# Can be tiled or not. Component is optional, defaults to all.
#
# Input format:  date.component(.tileX).nc
# Output format: date.component.var(.tileX).nc
#

export input_file_list=
export output_file_list=
echo "[COLE] created i/o lists"

find_output() {
    local directory="$1"
    echo "[COLE] FIND_OUTPUT directory : $directory"

    if [[ -d $directory ]]; then
        for item in $(ls $directory); do
            echo "item : $item"
            if [[ -d $item ]]; then
                find_output $item
            elif [[ $item == *.nc ]]; then
                export output_file_list=${output_file_list}$(shasum -a 512256 $directory/$item),
                echo -e "\n[COLE] added $directory/$item to output list"
            fi
        done
    else
        echo "[COLE] ERROR: $directory is invalid"
    fi
}

echo Arguments:
echo "    input dir: $inputDir"
echo "    output dir: $outputDir"
echo "    date: $date"
echo "    component: $component"
echo "    use subdirs: ${use_subdirs:=}"
echo Utilities:
type cdo

# Verify input directory exists and is a directory
if [[ ! -d $inputDir ]]; then
    echo "Error: Input directory '${inputDir}' does not exist or isn't a directory"
    exit 1
fi

# Verify output directory exists and is a directory
if [[ ! -d $outputDir ]]; then
    echo "Error: Output directory '${outputDir}' does not exist or isn't a directory"
    exit 1
fi

# Find the files to split
# extended globbing used to find both tiled and non-tiled files
cd $inputDir
shopt -s extglob

# If in sub-dir mode, process the sub-directories instead of the main one
if [[ $use_subdirs ]]; then
    for subdir in $(ls); do
        pushd $subdir
        files=$(echo *.$component?(.tile?).nc)

        # Exit if no input files are found
        if [[ $files =~ \* ]]; then
            echo No input files found, skipping the subdir "$subdir"
            popd
            continue
        fi

        # Create the output subdir if needed
        mkdir -p $outputDir/$subdir

        # Split the files by variable
        # Note: cdo may miss some weird land variables related to metadata/cell_measures
        for file in $files; do
            cdo --history splitname $file $outputDir/$subdir/$(echo $file | sed 's/nc$//')
            hash_val=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python /home/Cole.Harvey/postprocessing/data_lineage/bloomfilter/HashGen.py $inputDir/$subdir/$file)
            export input_file_list="${input_file_list}$file  $hash_val,"
            echo -e "\n[COLE] added $file to input list with hash_val: $hash_val"
        done
        cd $outputDir/$subdir
            for output_file in $(ls); do
                hash_val=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python /home/Cole.Harvey/postprocessing/data_lineage/bloomfilter/HashGen.py $output_file)
                export output_file_list="${output_file_list}${output_file}  ${hash_val},"
                echo -e "\n[COLE] added $(basename $output_file) to output list with hash_val: $hash_val"
            done
        cd ../..
        popd
    done
else
    files=$(echo *.$component?(.tile?).nc)

    # Exit if no input files are found
    if [[ $files =~ \* ]]; then
        echo ERROR: No input files found
        exit 1
    fi

    # Split the files by variable
    for file in $files; do
        cdo --history splitname $file $outputDir/$(echo $file | sed 's/nc$//')
        hash_val=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python /home/Cole.Harvey/postprocessing/data_lineage/bloomfilter/HashGen.py $inputDir/$file)
        export input_file_list="${input_file_list}$file  $hash_val,"
        echo -e "\n[COLE] added $inputDir/$file to input list with hash_val: $hash_val"
    done
    cd $outputDir
        for output_file in $(ls); do
            hash_val=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python /home/Cole.Harvey/postprocessing/data_lineage/bloomfilter/HashGen.py $output_file)
            export output_file_list="${output_file_list}${output_file}  ${hash_val},"
            echo -e "\n[COLE] added $(basename $output_file) to output list with hash_val: $hash_val"
        done
    cd ..
fi


echo "[COLE] epmt analysis and annotate"
which epmt

if [[ -n "$input_file_list" ]]; then
    echo -e "\n---input---"
    echo -e "epmt annotate DATA_LINEAGE_IN = \n	${input_file_list%*,}"
    epmt annotate EPMT_DATA_LINEAGE_IN="${input_file_list%*,}"
fi

if [[ -n "$output_file_list" ]]; then
    echo -e "\n---output---"
    echo -e "epmt annotate DATA_LINEAGE_OUT = \n    ${output_file_list%*,}"
    epmt annotate EPMT_DATA_LINEAGE_OUT="${output_file_list%*,}"
fi

echo Natural end of the NetCDF splitting
exit 0
