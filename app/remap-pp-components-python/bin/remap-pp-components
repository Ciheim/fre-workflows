#!/usr/bin/env python

# Description: Remap components that will be post-processed 

import os
import subprocess
import glob
import sys
from pathlib import Path
import metomi.rose.config as mrc

# Parse yaml directly for rose-app info
# Set variables
inputDir        = os.getenv('inputDir')
outputDir       = os.getenv('outputDir')
begin           = os.getenv('begin')
currentChunk    = os.getenv('currentChunk')
components      = os.getenv('components')
product         = os.getenv('product')
dirTSWorkaround = os.getenv('dirTSWorkaround')
ens_mem         = os.getenv('ens_mem')

print("Arguments:")
print("    input dir: "+inputDir)
print("    output dir: "+outputDir)
print("    begin: "+begin)
print("    current chunk: "+currentChunk)
print("    components: "+components)
print("    product: "+product)
print("    dirTSWorkaround: "+dirTSWorkaround)
if ens_mem != None:
  print("    ens_mem: "+ens_mem)
else:
  print("    ens_mem: None")
print("Utilities:")

COPY_TOOL = os.getenv('COPY_TOOL')
type(COPY_TOOL)

## Purpose: Verify that the input and output directories exists and are directories
## outputDir: output directory
## inputDir: input directory
def verify_dirs(inputDir,outputDir):
  # Verify input directory exists and is a directory
  if os.path.isdir(inputDir):
      print("Input directory is a valid directory")
  else:
      print(f"Error: Input directory {inputDir} is not a valid directory")
      sys.exit(1)

  # Verify output directory exists and is a directory
  if os.path.isdir(outputDir):
      print("Output directory is a valid directory")
  else:
      print(f"Error: Output directory {outputDir} is not a valid directory")
      sys.exit(1)

## Purpose: Create the output directory structure 
## outDir: output directory
## comp: component that will be post-processed
## freq: frequency
## chunk: chunk
## ens: ensemble member
## dirTS: directory time series workaround
def create_dir(outdir,comp,freq,chunk,ens,dirTS):
  # DEFINE DIR
  if ens:
    if dirTS:
      dir = f"{comp}/ts/{ens}/{freq}/{chunk}"
    else:
      dir = f"{comp}/{ens}/{freq}/{chunk}"
  else:
    if dirTS:
      dir = f"{comp}/ts/{freq}/{chunk}"
    else:
      dir = f"{comp}/{freq}/{chunk}"

  # Create dir from outputDir
  os.chdir(outdir)
  os.makedirs(dir,exist_ok=True)

  return(dir)

## Purpose: Print Bronx-style frequency given an ISO8601 duration
## iso_dura: frequency 
def freq_to_legacy(iso_dura):
    if iso_dura=='P1Y':
        return 'annual'
    elif iso_dura=='P1M':
        return 'monthly'
    elif iso_dura=='P3M':
        return 'seasonal'
    elif iso_dura=='P1D':
        return 'daily'
    elif iso_dura=='PT120H':
        return '120hr'
    elif iso_dura=='PT12H':
        return '12hr'
    elif iso_dura=='PT8H':
        return '8hr'
    elif iso_dura=='PT6H':
        return '6hr'
    elif iso_dura=='PT4H':
        return '4hr'
    elif iso_dura=='PT3H':
        return '3hr'
    elif iso_dura=='PT2H':
        return '2hr'
    elif iso_dura=='PT1H':
        return 'hourly'
    elif iso_dura=='PT30M':
        return '30min'
    else:
        return 'error'

## Purpose: Print Bronx-style frequency given an ISO8601 duration
## iso_dura: chunk
def chunk_to_legacy(iso_dura):
    if iso_dura[0]=='P':
        if iso_dura[-1:]=='M':
            brx_freq=iso_dura[1]+'mo'
        elif iso_dura[-1:]=='Y':
            brx_freq=iso_dura[1]+'yr'
        else:
            return 'error'
    else:
        return 'error'

    return brx_freq

## Purpose: Create bronx-style symlinks 
## freq: frequency
## chunk: chunk
## ens_member: ensemble member
## outDir: output directory
## comp: component
def bronx_style(freq, chunk, ens_member, outDir, component):
  freq_legacy = freq_to_legacy(freq)
  chunk_legacy = chunk_to_legacy(chunk)
  if chunk_legacy == "error":
    print(f"Error: Skipping legacy directory for chunk: {chunk}")
  else:
    if ens_member:
      dir1 = f"{outDir}/{component}/ts/{ens_member}"
      os.chdir(f"{outDir}/{component}/ts/{ens_member}")
    else:
      dir1 = f"{outDir}/{component}/ts"
      os.chdir(f"{outDir}/{component}/ts")
    
    os.makedirs(freq_legacy, exist_ok=True)
    os.chdir(freq_legacy)
    
    if not os.path.exists(chunk_legacy):
      os.symlink(f"{dir1}/{freq}/{chunk}", chunk_legacy)

  return(dir1)

## Purpose: Print legacy Bronx-like date template format given a frequency (ISO 8601 duration)
## iso_freq: frequency 
def freq_to_date_format(iso_freq):

    if iso_freq=='P1Y':
        return 'CCYY'
    elif iso_freq=='P1M':
        return 'CCYYMM'
    elif iso_freq=='P1D':
        return 'CCYYMMDD'
    elif (iso_freq[:2]=='PT') and (iso_freq[-1:]=='H'):
        return 'CCYYMMDDThh'
    else:
        print('ERROR: Unknown Frequency '+iso_freq)
        return

## Purpose: Print a date string to a truncated precision
##          - Accepts a date and frequency
##          - Outputs a date string with suitably reduced precision
##          - Test cases: '19790101T0000Z P1D', '19800101T0000Z P1M', '19790101T0000Z PT0.5H'
##          - Output using cylc (shared.sh calls in job logs): '19790101', '198001', '1979010100'
## date: date to begin post-processing
## freq: frequency
def truncate_date(date, freq):
    format=freq_to_date_format(freq)
    print(f"truncatedateformat: {format}")
    #in the shell version, this line simply gets run.
    #not clear to me why piping to tr is necessary, doesnt seem to change output at all
    #output =subprocess.Popen(["cylc", "date", "--template", format, date,
    #                          "|","tr","-d","T"],
    #                          stdout=subprocess.PIPE)
    output =subprocess.Popen(["cylc", "cycle-point", "--template", format, date],
                              stdout=subprocess.PIPE)

    bytedate = output.communicate()[0]
    date=str(bytedate.decode())
    print(f"truncatedate: {date}")

    #remove trailing newline
    date=date[:(len(date)-1)]

    #check for and remove 'T' if present
    if not date.isnumeric():
        date=date[:8]+date[-2:]

    return date

## Purpose: Pattern match and search for the correct files in the chunk directory
## vars: variables
## grid: output grid  
## source: source history files for post-processed component
## begin: date to begin post-processing 
## freq: frequency
def search_files(inputDir,vars,grid,source,freq,chunk,begin):
  # with glob - files seen as list
  if freq == "P0Y":
    if vars == "all":
      files = glob.glob(f"{source}.*.nc")
    else:
      for v in vars:
        files = glob.glob(f"{source}.{v}*.nc")
  else:
    if product == "ts":
      date = truncate_date(begin, freq)
      print(f"date: {date}")
    elif product == "av":
      date = truncate_date(begin, "P1Y")
      print(date)
    else:
      print("Product not set to ts or av.")
      sys.exit(2)

    if vars == "all":
      files = glob.glob(f"{source}.{date}-*.*.nc")
    else:
      for v in vars:
        print(f"var: {v}")
        files = glob.glob(f"{source}.{date}-*.{v}*.nc")

    if product == "av" and currentChunk == "P1Y":
      files = glob.glob(f"{source}.{date}.*.nc")

  return(files)

##################################### MAIN FUNCTION #####################################
## inputDir: input directory
## outputDir: output directory
## begin: date to begin post-processing 
## currentChunk: current chunk to post-process
## components: components that will be post-processed
## product: variable to define time series or time averaging
## dirTSWorkaround: time series workaround
## ens_mem: ensemble member number
def remap(inputDir,outputDir,begin,currentChunk,components,product,dirTSWorkaround,ens_mem):
  # Read rose config files (for now)
  configDir = os.getcwd()
  print(f"configuration directory: {configDir}") 
  config = mrc.load(f"{configDir}/rose-app-run.conf")

  # Verify the input and output directories
  verify_dirs(inputDir, outputDir)

  os.chdir(inputDir)

  for comp in config.get():
    if comp != "env" and comp != "command":
      if components != None and comp not in components:
        continue  
   
      #compOut: variable/field per component in rose config
      compOut = config.get([comp])

      #fields: info for each field 
      fields = compOut.get_value()

      # Define fields
      if fields.get("variables"):
        vars = fields.get("variables").get_value()
        vars = vars.split()
      else:
        vars = "all"

      #GRID
      if fields.get("grid") == None:
        grid = glob.glob("*")
      else:
        grid = fields.get("grid").get_value()
        grid = grid.split()

      for g in grid:
        if ens_mem != None:
          newdir = f"{inputDir}/{g}/{ens_mem}"
          os.chdir(newdir)
        else:
          os.chdir(f"{inputDir}/{g}")

        ## SOURCES
        if fields.get("sources") == None:
          sources = glob.glob("*")
        else:
          sources = fields.get("sources").get_value()
          sources = sources.split()

        for s in sources:
          # Start in grid directory
          os.chdir(f"{inputDir}/{g}")

          # Go into source directory 
          os.chdir(f"{inputDir}/{g}/{s}")

          #FREQ
          if fields.get("freq") == None:
            freq = glob.glob("*")
          else:
            freq = fields.get("freq").get_value()
            freq = freq.split()

          for f in freq:
            os.chdir(f"{inputDir}/{g}/{s}/{f}")

            #CHUNK
            if fields.get("chunk") == None:
              chunk = glob.glob("*")
            else:
              chunk = fields.get("chunk").get_value()
              chunk = chunk.split()

            for c in chunk:
              if c != currentChunk:
                continue 
              else:
                os.chdir(f"{inputDir}/{g}/{s}/{f}/{c}")
              
              # Create directory 
              dir = create_dir(outdir = outputDir,
                               comp = comp,
                               freq = f,
                               chunk = c,
                               ens = ens_mem,
                               dirTS = dirTSWorkaround)

              print(f"directory created: {dir}")
                
              # Create bronx-style symlinks for TS only
              if dirTSWorkaround:
                bronx_style(freq = f, 
                            chunk = c, 
                            ens_member = ens_mem,
                            outDir = outputDir,
                            component = comp)

              #ah7
            
              # Search for files in chunk directory
              os.chdir(f"{inputDir}/{g}/{s}/{f}/{c}")
              files = search_files(inputDir = inputDir,
                                   vars = vars,
                                   grid = g,
                                   source = s,
                                   freq = f,
                                   chunk = c,
                                   begin = begin) 
              print(f"files found: {files}")

              if not files:
                raise Exception(f"\nError: No input files found in {inputDir}/{g}/{s}/{f}/{c}")
              else:
                os.chdir(outputDir)

                for file in files:
                  newfile1 = file.split(".",1)[1]
                  newfile2 = f"{comp}.{newfile1}"

                  # If file exists, remove it (would exist if workflow was run previously)
                  if os.path.exists(f"{dir}/{newfile2}"):
                    os.remove(f"{dir}/{newfile2}")

                  # Replace with new file
                  link = ["ln", f"{inputDir}/{g}/{s}/{f}/{c}/{file}", f"{outputDir}/{dir}/{newfile2}"]
                  #ah12
              
                  run = subprocess.run( link ) 
                  ret = run.returncode

                  if run.returncode != 0:
                    copy = [ f"{COPY_TOOL}", f"{inputDir}/{g}/{s}/{f}/{c}/{file}", f"{outputDir}/{dir}/{newfile2}" ]
                    subprocess.run( copy )

                  #also works
                  #os.link(f"{inputDir}/{g}/{s}/{f}/{c}/{file}", f"{outputDir}/{dir}/{newfile2}")

  print("Component remapping complete")

if __name__ == '__main__':
   remap(inputDir,outputDir,begin,currentChunk,components,product,dirTSWorkaround,ens_mem)
