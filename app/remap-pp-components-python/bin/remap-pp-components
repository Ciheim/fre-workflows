#!/bin/bash
set -euo pipefail
set -x

#
# Remap variables from one convention (i.e. history) to another (i.e. PP components)
#

source $(dirname ${BASH_SOURCE[0]})/../shared/shared.sh

shopt -s extglob

# To read the Rose config file
if [[ -z ${CYLC_TASK_WORK_DIR:-} ]]; then
    config="rose config --file $(dirname ${BASH_SOURCE[0]})/../rose-app-run.conf"
else
    config="rose config --file $CYLC_TASK_WORK_DIR/rose-app-run.conf"
fi

echo Arguments:
echo "    input dir: $inputDir"
echo "    output dir: $outputDir"
echo "    begin: $begin"
echo "    current chunk: $currentChunk"
echo "    components: ${components:=}"
echo "    product: $product"
echo "    dirTSWorkaround: ${dirTSWorkaround:=}"
echo Utilities:
type $COPY_TOOL

# Verify input directory exists and is a directory
if [[ ! -d $inputDir ]]; then
    err "Error: Input directory '${inputDir}' does not exist or isn't a directory"
    exit 1
fi

# Verify output directory exists and is a directory
if [[ ! -d $outputDir ]]; then
    err "Error: Output directory '${outputDir}' does not exist or isn't a directory"
    exit 1
fi

cd $inputDir

# example output structure
# native/land_month/P1M/P4Y/land_month.198201-198512.snow.nc
# GRID/COMP/FREQ/CHUNK/COMP.DATES.VAR.nc

for key in $($config --keys | grep -v command | grep -v env); do
    compOut=${key%.*}
    # if $components is set, it is a space-separated list of acceptable components
    if [[ -n $components ]] && ! [[ " $components " =~ " $compOut " ]]; then
        continue
    fi
    echo "Processing component '$compOut' ($key)"

    vars=$($config --default=all $key variables)

    for grid in $($config --default=* $key grid); do
        pushd $grid || continue

        for source in $($config --default=* $key sources); do
            cd $source || continue

            for freq in $($config --default=* $key freq); do
                cd $freq || continue

                for chunk in $($config --default=* $key chunk); do
                    if [[ $chunk != $currentChunk ]]; then
                        continue
                    fi
                    cd $chunk || continue

                    if [[ $dirTSWorkaround ]]; then
                        dir=$outputDir/$compOut/ts/$freq/$chunk
                    else
                        dir=$outputDir/$compOut/$freq/$chunk
                    fi
                    mkdir -p $dir

                    # create the bronx-style symlinks for TS only
                    if [[ $dirTSWorkaround ]]; then
                        freq_legacy=$(freq_to_legacy $freq)
                        chunk_legacy=$(chunk_to_legacy $chunk)
                        if [[ $chunk_legacy == error ]]; then
                            err Skipping legacy directory for chunk $chunk
                        else
                            pushd $outputDir/$compOut/ts
                            mkdir -p $freq_legacy
                            cd $freq_legacy
                            if [[ ! -e $chunk_legacy ]]; then
                                ln -s ../$freq/$chunk $chunk_legacy
                            fi
                            popd
                        fi
                    fi

                    if [[ $freq == P0Y ]]; then
                        if [[ $vars == all ]]; then
                            files=$source.*?(.tile?).nc
                        else
                            for var in $vars; do
                                files="$files $source.$var?(.tile?).nc"
                            done
                        fi
                    else
                        if [[ $product == "ts" ]]; then
                            date1=$(truncate_date $begin $freq)
                        elif [[ $product == "av" ]]; then
                            date1=$(truncate_date $begin P1Y)
                        else
                            err "Product not set to ts or av"
                            exit 2
                        fi
                        if [[ $vars == all ]]; then
                            files=$source.$date1-*.*?(.tile?).nc
                        else
                            files=""
                            for var in $vars; do
                                files="$files $source.$date1-*.$var?(.tile?).nc"
                            done
                        fi
                        # unfortunate workaround needed for timeaverages which
                        # have only one year (i.e. YYYY, not YYYY-YYYY) in cases if chunksize=P1Y
                        if [[ $product == "av" && $currentChunk == "P1Y" ]]; then
                            files=$source.$date1.*?(.tile?).nc
                        fi
                    fi

                    if ! ls $files; then
                        err "No input files found; was looking for '$files' in $(pwd)"
                        exit 1
                    fi

                    for file in $files; do
                        newfile=$compOut.${file#*.}
                        if [[ ! -f $dir/$newfile ]]; then
                            ln $file $dir/$newfile || $COPY_TOOL $file $dir/$newfile
                        fi
                    done

                    cd ..
                done
                cd ..
            done
            cd ..
        done
        popd
    done
done

echo Natural end of the component remapping
exit 0
