#!/usr/bin/env python

# Description: Remap pp components 

import os
import subprocess
import glob
import sys
from pathlib import Path
import metomi.rose.config as mrc

# For my own testing: Set variables to play with -- WILL REMOVE
#inputDir = Path(os.getcwd()) / "rewrite_inputDir"
#outputDir = Path(os.getcwd()) / "rewrite_outputDir"
#begin = "00010101T0000Z" 
#currentChunk = "P1Y"
#components = ["atmos_scalar"]
##components = ["atmos", "atmos_cmip", "ocean"]
##components = ["land" ,"atmos_scalar"]
#product = "ts"
##dirTSWorkaround = ""
#dirTSWorkaround = "1"
#ens_mem = "" 
##ens_mem = "01"


##################################

# Parse yaml directly for rose-app info
# Set variables
inputDir        = os.getenv('inputDir')
outputDir       = os.getenv('outputDir')
begin           = os.getenv('begin')
currentChunk    = os.getenv('currentChunk')
components      = os.getenv('components')
product         = os.getenv('product')
dirTSWorkaround = os.getenv('dirTSWorkaround')
ens_mem         = os.getenv('ens_mem')

print("Arguments:")
print("    input dir: "+inputDir)
print("    output dir: "+outputDir)
print("    begin: "+begin)
print("    current chunk: "+currentChunk)
print("    components: "+components)
print("    product: "+product)
print("    dirTSWorkaround: "+dirTSWorkaround)
if ens_mem != None:
  print("    ens_mem: "+ens_mem)
else:
  print("    ens_mem: None")
print("Utilities:")

COPY_TOOL = os.getenv('COPY_TOOL')
type(COPY_TOOL)

##############################################################
## Purpose: Verify that the input and output directories exists and are directories
## outputDir: output directory
## inputDir: input directory
def verify_dirs(inputDir,outputDir):
  # Verify input directory exists and is a directory
  if os.path.isdir(inputDir):
      print("Input directory is a valid directory")
  else:
      print(f"Error: Input directory {inputDir} is not a valid directory")
      sys.exit(1)

  # Verify output directory exists and is a directory
  if os.path.isdir(outputDir):
      print("Output directory is a valid directory")
  else:
      print(f"Error: Output directory {outputDir} is not a valid directory")
      sys.exit(1)

##############################################################
## Purpose: Create the output directory structure 
## outDir: output directory
## comp: component that will be post-processed
## freq: frequency
## chunk: chunk
## ens: ensemble member
## dirTS: directory time series workaround
def create_dir(outdir,comp,freq,chunk,ens,dirTS):
  # DEFINE DIR
  if ens:
    if dirTS:
      dir = f"{comp}/ts/{ens}/{freq}/{chunk}"
    else:
      dir = f"{comp}/{ens}/{freq}/{chunk}"
  else:
    if dirTS:
      dir = f"{comp}/ts/{freq}/{chunk}"
    else:
      dir = f"{comp}/{freq}/{chunk}"

  # Create dir from outputDir
  os.chdir(outdir)
  os.makedirs(dir,exist_ok=True)

  return(dir)

##############################################################
## Purpose: Print Bronx-style frequency given an ISO8601 duration
## iso_dura: frequency 
def freq_to_legacy(iso_dura):
    if iso_dura=='P1Y':
        return 'annual'
    elif iso_dura=='P1M':
        return 'monthly'
    elif iso_dura=='P3M':
        return 'seasonal'
    elif iso_dura=='P1D':
        return 'daily'
    elif iso_dura=='PT120H':
        return '120hr'
    elif iso_dura=='PT12H':
        return '12hr'
    elif iso_dura=='PT8H':
        return '8hr'
    elif iso_dura=='PT6H':
        return '6hr'
    elif iso_dura=='PT4H':
        return '4hr'
    elif iso_dura=='PT3H':
        return '3hr'
    elif iso_dura=='PT2H':
        return '2hr'
    elif iso_dura=='PT1H':
        return 'hourly'
    elif iso_dura=='PT30M':
        return '30min'
    else:
        return 'error'
##############################################################
## Purpose: Print Bronx-style frequency given an ISO8601 duration
## iso_dura: chunk
def chunk_to_legacy(iso_dura):

    if iso_dura[0]=='P':
        if iso_dura[-1:]=='M':
            brx_freq=iso_dura[1]+'mo'
        elif iso_dura[-1:]=='Y':
            brx_freq=iso_dura[1]+'yr'
        else:
            return 'error'
    else:
        return 'error'

    return brx_freq
##############################################################
## Purpose: Create bronx-style symlinks 
## freq: frequency
## chunk: chunk
## ens_member: ensemble member
## outDir: output directory
## comp: component
def bronx_style(freq, chunk, ens_member, outDir, component):
  freq_legacy = freq_to_legacy(freq)
  chunk_legacy = chunk_to_legacy(chunk)
  if chunk_legacy == "error":
    print(f"Error: Skipping legacy directory for chunk: {chunk}")
  else:
    if ens_member:
      dir1 = f"{outDir}/{component}/ts/{ens_member}"
      os.chdir(f"{outDir}/{component}/ts/{ens_member}")
    else:
      dir1 = f"{outDir}/{component}/ts"
      os.chdir(f"{outDir}/{component}/ts")
    
    os.makedirs(freq_legacy, exist_ok=True)
    os.chdir(freq_legacy)
    
    if not os.path.exists(chunk_legacy):
      os.symlink(f"{dir1}/{freq}/{chunk}", chunk_legacy)

##############################################################
## Purpose: Print legacy Bronx-like date template format given a frequency (ISO 8601 duration)
## iso_freq: frequency 
def freq_to_date_format(iso_freq):

    if iso_freq=='P1Y':
        return 'CCYY'
    elif iso_freq=='P1M':
        return 'CCYYMM'
    elif iso_freq=='P1D':
        return 'CCYYMMDD'
    elif (iso_freq[:2]=='PT') and (iso_freq[-1:]=='H'):
        return 'CCYYMMDDThh'
    else:
        print('ERROR: Unknown Frequency '+iso_freq)
        return

##############################################################
## Purpose: Print a date string to a truncated precision
##          - Accepts a date and frequency
##          - Outputs a date string with suitably reduced precision
##          - Test cases: '19790101T0000Z P1D', '19800101T0000Z P1M', '19790101T0000Z PT0.5H'
##          - Output using cylc (shared.sh calls in job logs): '19790101', '198001', '1979010100'
## date: begin variable
## freq: frequency
def truncate_date(date, freq):
    format=freq_to_date_format(freq)

    #in the shell version, this line simply gets run.
    #we will simply print this command to screen for now. TO DO (maybe we can work around it?)
    #not clear to me why piping to tr is necessary, doesnt seem to change output at all
    #print('cylc date --template '+format+' '+date+' | tr -d T')
    #output =subprocess.Popen(["cylc", "date", "--template", format, date,
    #                          "|","tr","-d","T"],
    #                          stdout=subprocess.PIPE)
    output =subprocess.Popen(["cylc", "cycle-point", "--template", format, date],
                              stdout=subprocess.PIPE)

    bytedate = output.communicate()[0]
    #print(f"bytedate: {bytedate}")
    date=str(bytedate.decode())
    #print(f"date1: {date}")

    #remove trailing newline
    date=date[:(len(date)-1)]
    #print(f"date2: {date}")
    #ah8

    #check for and remove 'T' if present
    if not date.isnumeric():
        date=date[:8]+date[-2:]

    return date

##############################################################
## Purpose: Pattern match and search for the correct files in the chunk directory
## vars: variables
## source: 
## begin: 
## freq: frequency
def search_files(inputDir,vars,grid,source,freq,chunk,begin):
  # with glob - files seen as list
  if freq == "P0Y":
    if vars == "all":
      files = glob.glob(f"{inputDir}/{grid}/{source}/{freq}/{chunk}/{source}.*.nc")
      #print(files)
    else:
      for v in vars:
        files = glob.glob(f"{inputDir}/{grid}/{source}/{freq}/{chunk}/{source}.{v}*.nc")
  else:
    if product == "ts":
      date = truncate_date(begin, freq)
      print(f"date: {date}")
    elif product == "av":
      date = truncate_date(begin, "P1Y")
      print(date)
    else:
      print("Product not set to ts or av.")
      sys.exit(2)

    if vars == "all":
      files = glob.glob(f"{inputDir}/{grid}/{source}/{freq}/{chunk}/{source}.{date}-*.*.nc")
    else:
      #files = ""
      for v in vars:
        files = glob.glob(f"{inputDir}/{grid}/{source}/{freq}/{chunk}/{source}.{date}-*.{v}*.nc")

    if product == "av" and currentChunk == "P1Y":
      files = glob.glob(f"{inputDir}/{grid}/{source}/{freq}/{chunk}/{source}.{date}.*.nc")

  return(files)

##################################### MAIN FUNCTION #####################################
## Purpose: 
## inputDir: input directory
## outputDir: output directory
## begin: 
## currentChunk: 
## components: components that will be post-processed
## product: variable to define time series or time averaging
## dirTSWorkaround: time series workaround
## ens_mem: ensemble member number
def remap(inputDir,outputDir,begin,currentChunk,components,product,dirTSWorkaround,ens_mem):
  # Read rose config files (for now)
  configDir = os.getcwd()
  print(configDir) 
  config = mrc.load(f"{configDir}/rose-app-run.conf")

  # Verify the input and output directories
  verify_dirs(inputDir, outputDir)

  os.chdir(inputDir)

  for comp in config.get():
    if comp != "env" and comp != "command":
      if components != None and comp not in components:
        continue  
   
      #compOut: variable/field per component in rose config
      compOut = config.get([comp])

      #fields: info for each field 
      fields = compOut.get_value()

      # Define fields
      if fields.get("variables"):
        vars = fields.get("variables").get_value()
        vars = vars.split()
      else:
        vars = "all"
##
      #GRID
      if fields.get("grid") == None:
        grid = glob.glob("*")
      else:
        grid = fields.get("grid").get_value()
        grid = grid.split()

      for g in grid:
        #ah1
        if ens_mem != None:
          newdir = f"{inputDir}/{g}/{ens_mem}"
          #os.makedirs(newdir,exist_ok=True)
          os.chdir(newdir)
        else:
          #os.makedirs(grid,exist_ok=True)
          os.chdir(f"{inputDir}/{g}")
##
        ## SOURCES
        if fields.get("sources") == None:
          sources = glob.glob("*")
        else:
          sources = fields.get("sources").get_value()
          sources = sources.split()

        for s in sources:
          #ah2
          #print(s)
          # Start in grid directory
          os.chdir(f"{inputDir}/{g}")

          # Go into source directory 
          # os.makedirs(s,exist_ok=True)
          os.chdir(f"{inputDir}/{g}/{s}")
##
          #FREQ
          if fields.get("freq") == None:
            freq = glob.glob("*")
          else:
            freq = fields.get("freq").get_value()
            freq = freq.split()
            #os.makedirs(freq,exist_ok=True)

          for f in freq:
            #ah3
            os.chdir(f"{inputDir}/{g}/{s}/{f}")
##
            #CHUNK
            if fields.get("chunk") == None:
              chunk = glob.glob("*")
            else:
              chunk = fields.get("chunk").get_value()
              chunk = chunk.split()

            for c in chunk:
              #ah4
              if c != currentChunk:
                continue 
              else:
                os.chdir(f"{inputDir}/{g}/{s}/{f}/{c}")
                #os.makedirs(chunk,exist_ok=True)
              
              #ah5 - test has fake success - continues above through if statement
              # Create directory 
              dir = create_dir(outdir = outputDir,
                               comp = comp,
                               freq = f,
                               chunk = c,
                               ens = ens_mem,
                               dirTS = dirTSWorkaround)

              # Create bronx-style symlinks for TS only
              if dirTSWorkaround:
                bronx_style(freq = f, 
                            chunk = c, 
                            ens_member = ens_mem,
                            outDir = outputDir,
                            component = comp)

              # Search for files in chunk directory
              os.chdir(f"{inputDir}/{g}/{s}/{f}/{c}")
              files = search_files(inputDir = inputDir,
                                   vars = vars,
                                   grid = g,
                                   source = s,
                                   freq = f,
                                   chunk = c,
                                   begin = begin) 
              print(files)
              #ah6

              if not files:
                raise Exception(f"\nError: No input files found in {inputDir}/{g}/{s}/{f}/{c}")
              else:
                for file in files:
                  newfile = f"{comp}.{file}"
                  # If file exists, remove it (would exist if workflow was run previously)
                  if os.path.exists(f"{dir}/{newfile}"):
                    os.remove(f"{dir}/{newfile}")
              
                  # Replace with new file
                  link = [ "ln", f"{inputDir}/{g}/{s}/{f}/{c}/{file}", f"{dir}/{newfile}" ] 
                  subprocess.run(link)

                  #copy = [ f"{COPY_TOOL}", f"{inputDir}/{g}/{s}/{f}/{c}/{file}", f"{dir}/{newfile}" ] 
                  #subprocess.run(copy)

                  #os.symlink(f"{os.getcwd()}/{file}",f"{dir}/{newfile}") 
                  #os.system(f"ln {file} {dir}/{newfile}")
                  ## OR COPY TOOL
                  ## os.system(F"{COPY_TOOL} {os.getcwd()}/{file} {dir}/{newfile}")           

  print("Component remapping complete")

if __name__ == '__main__':
   remap(inputDir,outputDir,begin,currentChunk,components,product,dirTSWorkaround,ens_mem)
